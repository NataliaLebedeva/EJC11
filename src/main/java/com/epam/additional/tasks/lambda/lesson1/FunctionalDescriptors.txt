Predicate<T>            T -> boolean

Consumer<T>             T -> void

Function<T,R>           T -> R

Supplier<T>             () -> T

UnaryOperator<T>        T -> T

BinaryOperator<T,T>     (T, T) -> T (sum)

BiPredicate<L, R>       (L, R) -> boolean

BiConsumer<T, U>        (T, U) -> void

BiFunction<T, U, R>     (T, U) -> R



Method references:

static              RefType::staticMethod       (args) -> RefType.staticMethod(args)
bound instance      expr::instMethod            (args) -> expr.instMethod(args)
unbound inst        RefType::instMethod         (arg0, restArgs) -> arg0.instMethod(restArgs)
constructor         ClassName::new              (args) -> new ClassName(args)